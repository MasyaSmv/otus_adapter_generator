<?php

namespace Masyasmv\Adapter;

use ReflectionClass;
use RuntimeException;

class AdapterGenerator
{
    /**
     * Генерирует класс-адаптер для указанного интерфейса и сохраняет его в директорию.
     *
     * @param string $interfaceFqcn Полное имя интерфейса (Fully Qualified Class Name).
     * @param string $outputDir     Папка для сохранения сгенерированного файла.
     *
     * @throws RuntimeException Если интерфейс не найден.
     */
    public function generate(string $interfaceFqcn, string $outputDir): void
    {
        // 1. Проверка существования интерфейса в рантайме
        if (!interface_exists($interfaceFqcn)) {
            throw new RuntimeException("Интерфейс $interfaceFqcn не найден");
        }

        // 2. Получаем рефлексию интерфейса для чтения метаданных
        $ref = new ReflectionClass($interfaceFqcn);

        // 3. Формирование имени адаптера:
        //    - Берём короткое имя интерфейса (ITest -> ITest)
        //    - Убираем префикс 'I' (если есть) и добавляем 'Adapter'
        // Пример: ITest -> TestAdapter
        $shortName   = $ref->getShortName();
        $adapterName = preg_replace('/^I/', '', $shortName) . 'Adapter';

        // 4. Задаём namespace для адаптера: оригинальный namespace + '\\AutoGenerated'
        $ns = $ref->getNamespaceName() . 'AutoGenerated';

        // 5. Начинаем собирать строку с кодом PHP-файла адаптера
        $code  = "<?php\n";
        $code .= "namespace $ns;\n\n";
        $code .= "// Используем IoC-контейнер и интерфейс команд\n";
        $code .= "use ICommand;\n";
        $code .= "use IoC;\n\n";
        $code .= "// Автоматически сгенерированный адаптер для интерфейса $interfaceFqcn\n";
        $code .= "class $adapterName implements \\$interfaceFqcn\n";
        $code .= "{\n";
        $code .= "    // Храним исходный объект, реализующий интерфейс\n";
        $code .= "    private \$obj;\n\n";
        $code .= "    /**\n";
        $code .= "     * Конструктор адаптера принимает объект-реализацию интерфейса\n";
        $code .= "     *\n";
        $code .= "     * @param object \$obj Исходный объект\n";
        $code .= "     */\n";
        $code .= "    public function __construct(object \$obj)\n";
        $code .= "    {\n";
        $code .= "        \$this->obj = \$obj;  // Сохраняем ссылку на объект\n";
        $code .= "    }\n\n";

        // 6. Обрабатываем методы интерфейса для генерации тела адаптера
        foreach ($ref->getMethods() as $method) {
            // 6.1. Генерируем только методы, объявленные в самом интерфейсе
            if ($method->getDeclaringClass()->getName() !== $interfaceFqcn) {
                continue;
            }

            // Имя метода, тип возвращаемого значения и параметры
            $name   = $method->getName();
            $return = $method->getReturnType()?->getName() ?: 'void';
            $params = [];
            $args   = [];

            // Собираем сигнатуру и аргументы для передачи в IoC::resolve
            foreach ($method->getParameters() as $param) {
                $type       = $param->getType()?->getName() ?: 'mixed';
                $paramName  = '$' . $param->getName();
                $params[]   = "$type $paramName";
                $args[]     = $paramName;
            }
            $sig      = implode(', ', $params);            // строка вида "int $x, string $y"
            $callArgs = implode(', ', $args);             // строка вида "$x, $y"

            // Ключ действия: для геттеров/сеттеров берём часть имени после get/set
            $key = strtolower(preg_replace('/^get|^set/', '', $name));

            // Генерация геттера: getX()
            if (str_starts_with($name, 'get')) {
                // если это встроенный тип (int, string, bool, float), используем просто 'int', 'string' и т.д.
                if ($method->getReturnType()?->isBuiltin()) {
                    $resolveType = "'" . $return . "'";
                } else {
                    // иначе — реальное имя класса
                    $resolveType = $return . '::class';
                }
                $code .= "    // Метод $name будет получать значение через IoC-контейнер\n";
                $code .= "    public function $name(): $return\n";
                $code .= "    {\n";
                $code .= "        return IoC::resolve($resolveType, \"$interfaceFqcn:$key.get\", \$this->obj);\n";
                // Генерация сеттера: setX(\$value)
            } elseif (str_starts_with($name, 'set')) {
                $code .= "    // Метод $name будет создавать и выполнять команду через IoC\n";
                $code .= "    public function $name($sig): void\n";
                $code .= "    {\n";
                $code .= "        IoC::resolve(ICommand::class, \"$interfaceFqcn:$key.set\", \$this->obj, $callArgs)\n";
                $code .= "            ->execute();\n";
                // Генерация для других методов
            } else {
                $code .= "    // Метод $name нестандартный, вызываем IoC::resolve напрямую\n";
                $code .= "    public function $name($sig): $return\n";
                $code .= "    {\n";
                $code .= "        return IoC::resolve($return::class, \"$interfaceFqcn:$name\", \$this->obj";
                if ($callArgs !== '') {
                    $code .= ", $callArgs";
                }
                $code .= ");\n";
            }
            $code .= "    }\n\n";
        }

        // 7. Закрываем тело класса
        $code .= "}\n";

        // 8. Создаём папку для сохранения, если её нет
        $dir = rtrim($outputDir, '/');
        if (!is_dir($dir)) {
            mkdir($dir, 0775, true);
        }

        // 9. Сохраняем сформированный файл адаптера
        file_put_contents("$dir/$adapterName.php", $code);
    }
}
